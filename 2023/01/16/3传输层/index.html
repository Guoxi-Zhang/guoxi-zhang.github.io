<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>计算机网络——第三章：传输层 | Guoxi's Blog</title><meta name="author" content="Guoxi Zhang"><meta name="copyright" content="Guoxi Zhang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="传输层传输层概述 传输协议处于操作系统内核之中，运行在终端（路由器没有传输层与应用层） 发送方传输层：切割messages,封装为segments 接收方传输层：组装segments为messages   传输层协议为运行在不同主机上的应用进程之间提供了**逻辑通信 （logic communication)**功能。 传输层有两个可选协议：TCP, UDP  和网络层对比传输层：为两端计算机的进">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络——第三章：传输层">
<meta property="og:url" content="https://guoxi-zhang.github.io/2023/01/16/3%E4%BC%A0%E8%BE%93%E5%B1%82/index.html">
<meta property="og:site_name" content="Guoxi&#39;s Blog">
<meta property="og:description" content="传输层传输层概述 传输协议处于操作系统内核之中，运行在终端（路由器没有传输层与应用层） 发送方传输层：切割messages,封装为segments 接收方传输层：组装segments为messages   传输层协议为运行在不同主机上的应用进程之间提供了**逻辑通信 （logic communication)**功能。 传输层有两个可选协议：TCP, UDP  和网络层对比传输层：为两端计算机的进">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Guoxi-Zhang/myBlog/main/public/img/avatar.png">
<meta property="article:published_time" content="2023-01-15T16:09:53.610Z">
<meta property="article:modified_time" content="2023-01-15T16:28:57.788Z">
<meta property="article:author" content="Guoxi Zhang">
<meta property="article:tag" content="大三第一学期">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="计网">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Guoxi-Zhang/myBlog/main/public/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://guoxi-zhang.github.io/2023/01/16/3%E4%BC%A0%E8%BE%93%E5%B1%82/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机网络——第三章：传输层',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-16 00:28:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/Guoxi-Zhang/myBlog/main/public/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/Guoxi-Zhang/myBlog/main/public/img/top_img1.jpeg')"><nav id="nav"><span id="blog-info"><a href="/" title="Guoxi's Blog"><span class="site-name">Guoxi's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机网络——第三章：传输层</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-15T16:09:53.610Z" title="发表于 2023-01-16 00:09:53">2023-01-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-15T16:28:57.788Z" title="更新于 2023-01-16 00:28:57">2023-01-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计算机网络——第三章：传输层"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="传输层概述"><a href="#传输层概述" class="headerlink" title="传输层概述"></a>传输层概述</h2><ul>
<li>传输协议处于操作系统内核之中，运行在<strong>终端</strong>（<strong>路由器没有传输层与应用层</strong>）<ul>
<li>发送方传输层：切割messages,封装为segments</li>
<li>接收方传输层：组装segments为messages</li>
</ul>
</li>
<li>传输层协议为运行在不同主机上的<strong>应用进程</strong>之间提供了**逻辑通信 （logic communication)**功能。</li>
<li>传输层有两个可选协议：TCP, UDP</li>
</ul>
<h3 id="和网络层对比"><a href="#和网络层对比" class="headerlink" title="和网络层对比"></a>和网络层对比</h3><p>传输层：为两端计算机的<strong>进程</strong>提供传输通道</p>
<p>网络层：为两个<strong>主机</strong>提供传输通道</p>
<h3 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h3><ul>
<li>TCP:可靠、按序传输<ul>
<li>阻塞控制</li>
<li>流量控制</li>
<li>连接设置</li>
</ul>
</li>
<li>UDP:不可靠、乱序传输<ul>
<li>尽力交付(best-effort)</li>
</ul>
</li>
<li>都不能提供的服务<ul>
<li>延迟保证</li>
<li>带宽保证</li>
</ul>
</li>
<li>协议对应关系：<ul>
<li>TCP: HTTP, SWTP&amp;POP3, routing, FTP</li>
<li>UDP: DNS, SNMP</li>
</ul>
</li>
</ul>
<h2 id="多路复用-multiplexing-与分解-demultiplexing"><a href="#多路复用-multiplexing-与分解-demultiplexing" class="headerlink" title="多路复用(multiplexing)与分解(demultiplexing)"></a>多路复用(multiplexing)与分解(demultiplexing)</h2><ul>
<li><p>复用：数据汇聚的过程：</p>
<ul>
<li>应用层-&gt;socket</li>
<li>在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（这将在以后用于分解)从而生成报文段，然后将报文段传递到网络</li>
</ul>
</li>
<li><p>分解：数据拆分的过程：</p>
<ul>
<li>传输层-&gt;socket</li>
<li>传输层检查segment中一些字段,标识出接收套接字，进而将报文段定向到该套接字。</li>
</ul>
</li>
</ul>
<h3 id="分解原理"><a href="#分解原理" class="headerlink" title="分解原理"></a>分解原理</h3><p>主机使用<strong>IP地址</strong>和<strong>端口号</strong>将segment定向到对应的socket，分别为src, dest</p>
<ul>
<li>UDP只用dest port区分</li>
<li>TCP使用4个数据区分：src IP, src port, dest IP, dest port</li>
</ul>
<p>TCP和UDP的端口独立，即可以有两个占用80端口的进程（分别用TCP,UDP）</p>
<img src="image-20221024093915668.png" alt="shadow-image-20221024093915668" style="zoom: 67%;">

<ul>
<li>端口号：0-65535<ul>
<li>0-1023：well-known port ，一般供给服务器使用</li>
<li>1024-65535：随机分配给需要网络的进程</li>
</ul>
</li>
</ul>
<h2 id="UDP-无连接传输层协议"><a href="#UDP-无连接传输层协议" class="headerlink" title="UDP:无连接传输层协议"></a>UDP:无连接传输层协议</h2><p><strong>User Datagram Protocol [RFC 768]</strong></p>
<ul>
<li>不可靠，可能丢包或者乱序提交给应用层进程</li>
<li>不需要事先连接<ul>
<li>无握手过程</li>
<li>每个UDP segment<strong>独立处理</strong>：message与segment一一对应（TCP将相近的发往同个dest的msg合并为一个segment:m对n）</li>
</ul>
</li>
<li>可靠的UDP: 应用层代码中增添可靠性检测</li>
</ul>
<h3 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h3><p>包头：4个16位字段</p>
<p><img src="image-20221024104718596.png" alt="shadow-image-20221024104718596"></p>
<p>length:记录整个包（含包头）的大小msg+ 8 byte。超过length UDP会把包丢掉</p>
<p>小包头，无阻塞控制</p>
<h3 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h3><p>首先发送方要计算checksum</p>
<ul>
<li>将段的内容看作16bits的整数</li>
<li>校验和计算：计算所有整数的和，<strong>进位加到和的后面</strong>，将得到的值<strong>按位取反</strong>，得到校验和</li>
<li>发送方把checksum放入header的校验和字段里面</li>
</ul>
<p>接着，当接收方收到后，验证:</p>
<ul>
<li>计算所收到的段的校验和</li>
<li><strong>把它和校验和字段进行对比</strong></li>
<li>不相等即发现了错误，相<strong>等并不代表一定没有错误</strong></li>
</ul>
<p>相等只代表我们没有检测出错误，但其实可能有错误，比如有2个位发生翻转的情况就检测不出来。</p>
<p><img src="image-20221031081839606.png" alt="image-20221031081839606"></p>
<p><img src="image-20221116082537483.png" alt="image-20221116082537483"></p>
<h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><p><strong>可靠数据传输协议（reliable data transfer protocol）</strong>：数据可以通过一条可靠的信道进行传输。借助于可靠信道，传输数据比特就<strong>不会受到损坏(由0变为1,或者相反)或丢失</strong>，而且<strong>所有数据都是按照其发送顺序进行交付</strong>。这恰好就是TCP向调用它的因特网应用所提供的服务模型。</p>
<p>由于可靠数据传输协议的<strong>下层协议也许是不可靠的</strong>，因此这是一项困难的任务。例如，TCP是在不可靠的（IP）端到端网络层之上实现的可靠数据传输协议。更一般的情况是，两个可靠通信端点的下层可能是由一条物理链路（如在链路级数据传输协议的场合下）组成或是由一个全球互联网络（如在运输级协议的场合下）组成。然而，就我们的目的而言，我们可将<strong>较低层直接视为不可靠的点对点信道。</strong></p>
<img src="image-20221027140212404.png" alt="shadow-image-20221027140212404" style="zoom:80%;">



<h3 id="构造RDT"><a href="#构造RDT" class="headerlink" title="构造RDT"></a>构造RDT</h3><p>一步步地研究下述一系列协议，它们一个比一个更为复杂，最后得到一个无错、可靠的数据传输协议。</p>
<ul>
<li>RDT涉及的4个动作：</li>
</ul>
<p><img src="image-20221031082636611.png" alt="image-20221031082636611"></p>
<ul>
<li><p>假设RDT仅考虑单向数据发送（不会同时都向对方发数据，双向的数据传输问题实际上是 2 个单向数据传输问题的综合）。</p>
</li>
<li><p>使用有限状态机来描述RDT：</p>
  <img src="image-20221031083259671.png" alt="image-20221031083259671" style="zoom:80%;">

<ul>
<li>在该状态时，下一个状态只由下一个事件唯一决定</li>
<li>虚线箭头：初始化</li>
<li>横线：上面是事件发生，下面是该对象的反应动作</li>
<li>$\Lambda$ 符号：NULL，什么都不做</li>
</ul>
</li>
<li><p><code>rdt_send()</code> 和 <code>deliver_date()</code> 本层和上层的接口</p>
</li>
<li><p><code>udt_send()</code> 和 <code>udt_rcv()</code> 本层和下层的接口</p>
</li>
</ul>
<h4 id="rdt-1-0-经完全可靠信道"><a href="#rdt-1-0-经完全可靠信道" class="headerlink" title="rdt 1.0 经完全可靠信道"></a>rdt 1.0 经完全可靠信道</h4><p>发送方和接收方有限状态机的定义：</p>
<p><img src="image-20221027142019407.png" alt="shadow-image-20221027142019407"></p>
<h4 id="rdt-2-0-经具有比特差错信道"><a href="#rdt-2-0-经具有比特差错信道" class="headerlink" title="rdt 2.0 经具有比特差错信道"></a>rdt 2.0 经具有比特差错信道</h4><p><strong>重传机制：</strong></p>
<ul>
<li>肯定确认  *acknowledgements (ACKs)*： <font>OK</font></li>
<li>否定确认 *negative acknowledgements (NAKs)*：<font>请求重传</font></li>
</ul>
<p>基于这样重传机制的可靠数据传输协议称为<strong>自动重传请求 （Automatic.Repeat reQuest，ARQ)协议。</strong></p>
<p><strong>rdt2.0中提供了新功能：</strong></p>
<ul>
<li><strong>错误检测</strong>：checksum，用来检测比特差错</li>
<li><strong>反馈</strong>：control msgs (ACK,NAK) from receiver to sender</li>
</ul>
<p>有限状态机定义($\Lambda 表示action为空$ )：</p>
<table>
<thead>
<tr>
<th><img src="image-20221027142915707.png" alt="shadow-image-20221027142915707"></th>
<th><img src="image-20221027142933962.png" alt="shadow-image-20221027142933962"></th>
</tr>
</thead>
</table>
<h5 id="rdt-2-1"><a href="#rdt-2-1" class="headerlink" title="rdt 2.1"></a>rdt 2.1</h5><p>如果rdt2.0 的<strong>ACK包出现比特错误</strong>。发送方不知道接受方是否成功递交，简单重发又会可能出现重复递交问题。因此rdt2.1用来处理重复递交问题。发送方会给每个包加入一个序列号（<em><strong>sequence number：1bit，只有0&#x2F;1</strong></em>），接收方会丢掉重复包.</p>
<ul>
<li>因为rdt为停等协议，每次仅处理一个包，因此避免重复递交仅需要两个不同的序列号（如果是流水线分组，需要更多位）</li>
<li><strong>发送方：</strong><ul>
<li>在分组中加入序列号</li>
<li>两个序列号（0，1）就足够了</li>
<li>必须检测 ACK&#x2F;NAK 是否出错（需要 EDC，error-detection and-correction）</li>
<li>状态数变成了两倍<ul>
<li>必须记住当前分组的序列号为 0 还是 1</li>
</ul>
</li>
</ul>
</li>
<li><strong>接收方：</strong><ul>
<li>必须检测接收到的分组是否是重复的<ul>
<li>状态会指示希望接收到的分组的序号为 0 还是 1</li>
</ul>
</li>
<li>注意：接收方并不知道发送方是否正确收到了其 ACK&#x2F;NAK<ul>
<li>没有安排确认的确认</li>
<li>只是<strong>根据对方下次发过来的分组，才知道有没有收到</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>发送方：</strong></p>
<p><img src="image-20221027143313763.png" alt="shadow-image-20221027143313763"></p>
<p><strong>接受方：</strong></p>
<p><img src="image-20221027143409200.png" alt="shadow-image-20221027143409200"></p>
<p><strong>运行</strong>：</p>
<p><img src="image-20221116083252216.png" alt="image-20221116083252216"></p>
<h5 id="rdt2-2：无-NAK-的协议"><a href="#rdt2-2：无-NAK-的协议" class="headerlink" title="rdt2.2：无 NAK 的协议"></a>rdt2.2：无 NAK 的协议</h5><p>不需要NAK的协议，在ACK中带有序列号。接收方收到重复的ACK（接收方发送序列号相反的ACK）代表NAK。</p>
<p>引入2.2原因：为了继续升级为TCP做准备，由于TCP为pipeline协议，多个包在链路上发送可能会乱序，如果采用NAK和ACK，发送方无法鉴别反馈包针对的是哪个包，因此<strong>采用带编号的ACK，能够区分反馈的是哪个包</strong></p>
<ul>
<li>功能同 rdt2.1，但只使用 ACK（ACK要编号）</li>
<li>接收方<strong>对最后正确接收的分组发 ACK</strong>，以替代 NAK<ul>
<li>接收方必须显式地包含被正确接收分组的序号</li>
<li>把当前分组的否定确认用前面一个分组的肯定确认来代替，这样就不用 NAK 了</li>
</ul>
</li>
<li>当收到<strong>重复的 ACK</strong>（如：再次收到 ack0）时，<strong>发送方与收到 NAK 采取相同的动作：重传当前分组</strong></li>
</ul>
<p><img src="image-20221027143641941.png" alt="shadow-image-20221027143641941"></p>
<p><strong>运行</strong>：</p>
<p><img src="image-20221116083537511.png" alt="image-20221116083537511"></p>
<p><img src="image-20221116083548824.png" alt="image-20221116083548824"></p>
<h4 id="rdt-3-0经具有比特差错的丢包信道"><a href="#rdt-3-0经具有比特差错的丢包信道" class="headerlink" title="rdt 3.0经具有比特差错的丢包信道"></a>rdt 3.0经具有比特差错的丢包信道</h4><p>假设<strong>除了比特差错外还存在丢包。</strong></p>
<ul>
<li>会导致死锁</li>
<li>机制还不够处理这种状况<ul>
<li>校验和</li>
<li>序列号</li>
<li>ACK</li>
<li>重传</li>
</ul>
</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li><p>发送方等待接收ACK一段时间，没有收到ACK便重传</p>
</li>
<li><p>如果ACK仅是超时到达而不是丢包</p>
<ul>
<li>重传会导致重复递交，带序列号的ACK会处理该问题</li>
<li>接收方必须指明被正确接收的序列号</li>
</ul>
</li>
<li><p>需要一个倒计数定时器</p>
</li>
<li><p>实际上还是存在问题：延迟足够多时间，重发后即便有序列号<strong>，还是会导致数据重复（见下面RDT缺陷）</strong></p>
</li>
</ul>
<p><strong>发送方：</strong></p>
<img src="image-20221031095402117.png" alt="shadow-image-20221031095402117">

<p><strong>运行过程：</strong></p>
<p><img src="image-20221031095453366.png" alt="shadow-image-20221031095453366"></p>
<p><img src="image-20221031095534001.png" alt="shadow-image-20221031095534001"></p>
<p>RDT缺陷：不能解决因路由延迟导致的重复递交：</p>
<img src="image-20221031095336036.png" alt="image-20221031095336036" style="zoom:67%;">

<p><strong>停等RDT的性能问题</strong>：</p>
<p><img src="image-20221116083951040.png" alt="shadow-image-20221116083951040"></p>
<p>高带宽、高传播延迟，导致较大的带宽时延积以及<strong>极低的传播效率</strong>。该协议严重限制了物理资源的使用！</p>
<h3 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h3><img src="image-20221031101859919.png" alt="shadow-image-20221031101859919" style="zoom:80%;">

<p><strong>相对于停等的性能优化：</strong></p>
<p><img src="image-20221116083916587.png" alt="image-20221116083916587"></p>
<h4 id="GBN-go-Back-N"><a href="#GBN-go-Back-N" class="headerlink" title="GBN (go-Back-N)"></a>GBN (<em>go-Back-N</em>)</h4><ul>
<li>发送方可以一次性发送最多N个没被确认（ACK）的包。N被称为<strong>窗口大小</strong> </li>
<li>收方发送<strong>累计相应的ACK</strong>: 收到ACK3则表示0，1，2，3包均被递交<ul>
<li><strong>丢掉乱序到达的包</strong>（传输过程中产生gap）以及其之后的所有包</li>
<li><strong>ACK最后一个按序到达的包</strong></li>
</ul>
</li>
<li>发送方启动一个timer<strong>等待最后一个没被ACK的包</strong>，当超时后重传该包及之后的所有包</li>
</ul>
<h4 id="SR-selective-repeat"><a href="#SR-selective-repeat" class="headerlink" title="SR (selective repeat)"></a>SR (<em>selective repeat</em>)</h4><ul>
<li>发送方可以一次性发送最多N个没被确认（ACK）的包。</li>
<li>接收方<strong>为每一个包发送单独的ACK</strong>：每一个ACK仅表示一个包被递交（或缓存）<ul>
<li>接收方<strong>buffer乱序包</strong></li>
<li><strong>ACK收到的包</strong>（即使是乱序包），等待发送方超时重发</li>
<li>收到重发的包后ACK 包N 结束</li>
</ul>
</li>
<li>发送方启动一个timer<strong>等待每一个没被ACK的包</strong>，超时后<strong>仅重发没被ACK的包</strong></li>
</ul>
<img src="image-20221031104552298.png" alt="image-20221031104552298" style="zoom:67%;">

<h4 id="滑动窗口概述"><a href="#滑动窗口概述" class="headerlink" title="滑动窗口概述"></a>滑动窗口概述</h4><p><img src="image-20221031105351677.png" alt="shadow-image-20221031105351677"></p>
<p><strong>窗口属性：</strong></p>
<ul>
<li>窗口大小：N</li>
<li>位置：左边界在队列中的位置为窗口的position</li>
</ul>
<p>从<strong>position到position + N - 1</strong> 的包均在窗口中</p>
<p><strong>窗口大小和序列号取值的关系:</strong></p>
<ul>
<li>序列号取值如果和窗口大小相等，在一些情况下无法识别是重发包还是新的包，会导致重复递交不再可靠</li>
<li>对 GBN：序列号大小至少为窗口大小+1</li>
<li>对 SR：序列号大小至少为？</li>
</ul>
<p><strong>发送缓冲区</strong>:（size &#x3D; min(rwnd, cwnd)）</p>
<ul>
<li><p>形式：内存中的一个区域，落入缓冲区的分组可以发送</p>
</li>
<li><p>功能：用于<strong>存放已发送，但是没有得到确认的分组</strong></p>
</li>
<li><p>必要性：需要重发时可用</p>
</li>
<li><p>大小：一次最多可以发送多少个未经确认的分组</p>
<ul>
<li>停止等待协议 SW&#x3D;1</li>
<li>流水线协议 SW&gt;1，合理的值，不能很大，链路利用率不能够超 100%</li>
</ul>
</li>
<li><p>分组 :</p>
<ul>
<li>未发送的：落入发送缓冲区的分组，可以连续发送出去（缓冲区还有空间，上层就可以先交分组到缓冲区）</li>
<li>已经发送出去的、等待对方确认的分组：发送缓冲区的分组只有得到确认才能删除（先留着便于检错重发和超时重发）</li>
</ul>
</li>
</ul>
<p><strong>发送窗口：发送缓冲区内容的一个范围</strong>:那些<strong>已发送但是未经确认分组的序号构成的空间</strong>（绿色部分）</p>
<ul>
<li>发送窗口的最大值&lt;&#x3D;发送缓冲区的值  </li>
<li>一开始：没有发送任何一个分组<ul>
<li>后沿&#x3D;前沿</li>
<li>之间为发送窗口的尺寸&#x3D;0</li>
</ul>
</li>
<li>前沿移动：每发送一个分组，前沿前移一个单位<ul>
<li><img src="image-20221116084451186.png" alt="image-20221116084451186"></li>
<li>前沿移动的极限：发送缓冲区</li>
</ul>
</li>
<li>注意实际实现时，<strong>窗口不动，滑动的是分组</strong>；为了方便表示：分组不动，窗口滑动</li>
<li>后沿移动<ul>
<li>条件：收到老分组的确认</li>
<li>结果：发送缓冲区罩住新的分组，来了分组可以发送</li>
<li>移动极限：不超过前沿</li>
<li>移动过程图<ul>
<li><img src="image-20221116084526352.png" alt="image-20221116084526352"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="滑动窗口实现"><a href="#滑动窗口实现" class="headerlink" title="滑动窗口实现"></a>滑动窗口实现</h5><p><strong>发送窗口</strong></p>
<ul>
<li><img src="image-20221116084806569.png" alt="image-20221116084806569"></li>
</ul>
<p><strong>接收窗口 (receiving window)&#x3D;接收缓冲区</strong></p>
<ul>
<li><p>接收窗口用于控制哪些分组可以接收</p>
<ul>
<li>只有收到的分组序号落入接收窗口内才允许接收</li>
<li>若序号在接收窗口之外，则丢弃</li>
</ul>
</li>
<li><p>接收窗口尺寸 Wr&#x3D;1，则只能顺序接收</p>
</li>
<li><p>接收窗口尺寸 Wr&gt;1，则可以乱序接收</p>
<ul>
<li>但是提交给上层的分组要按顺序</li>
</ul>
</li>
<li><p>例子：Wr＝1，在0的位置；只有0号分组可以接收；向前滑动一个，罩在1的位置，如果来了第2号分组，则丢弃</p>
<ul>
<li><img src="image-20221116084904716.png" alt="image-20221116084904716"></li>
</ul>
</li>
<li><p>接收窗口的滑动和发送确认</p>
<ul>
<li>滑动：<ul>
<li>低序号的分组到来，接收窗口移动</li>
<li>高序号分组乱序到，<strong>缓存但不交付</strong>（因为要实现rdt，不允许失序），不滑动</li>
</ul>
</li>
<li>发送确认：<ul>
<li>接收窗口尺寸&#x3D;1;发送连续收到的最大的分组确认（累计确认）<ul>
<li>GBN 协议</li>
</ul>
</li>
<li>接收窗口尺寸&gt;1;收到分组，发送那个分组的确认（非累计确认）<ul>
<li>SR 协议</li>
</ul>
</li>
</ul>
</li>
<li><img src="image-20221116085010912.png" alt="image-20221116085010912"></li>
<li><img src="image-20221116085020681.png" alt="image-20221116085020681"></li>
</ul>
</li>
</ul>
<h3 id="流水线协议讨论"><a href="#流水线协议讨论" class="headerlink" title="流水线协议讨论"></a>流水线协议讨论</h3><h4 id="流水线协议下的窗口互动"><a href="#流水线协议下的窗口互动" class="headerlink" title="流水线协议下的窗口互动"></a>流水线协议下的窗口互动</h4><p><strong>正常情况下的窗口互动</strong></p>
<ul>
<li><img src="image-20221116085511365.png" alt="image-20221116085511365"></li>
</ul>
<p><strong>异常情况下 GBN 的窗口互动</strong></p>
<ul>
<li>乱序到达的情况</li>
<li><img src="image-20221116085528728.png" alt="image-20221116085528728"></li>
</ul>
<p><strong>异常情况下 SR 的窗口互动</strong></p>
<ul>
<li>乱序到达的情况</li>
<li><img src="image-20221116085538861.png" alt="image-20221116085538861"></li>
</ul>
<h3 id="GBN-协议和-SR-协议的异同"><a href="#GBN-协议和-SR-协议的异同" class="headerlink" title="GBN 协议和 SR 协议的异同"></a>GBN 协议和 SR 协议的异同</h3><p><strong>相同之处</strong></p>
<ul>
<li>发送窗口&gt;1</li>
<li>一次能够可发送多个未经确认的分组</li>
</ul>
<p><strong>不同之处</strong></p>
<ul>
<li>GBN：接收窗口尺寸&#x3D;1<ul>
<li>接收端<ul>
<li>只能顺序接收</li>
<li>只发送累计型确认 cumulative ack<ul>
<li>接收端如果发现 gap，不确认新到来的分组</li>
</ul>
</li>
</ul>
</li>
<li>发送端<ul>
<li>发送端最多在流水线中有 N 个未确认的分组</li>
<li>从表现来看，一旦一个分组没有发成功，如：0,1,2,3,4; 假如 1 未成功，234 都发送出去了，要返回 1 再发送；<strong>GB1</strong> </li>
<li>发送端拥有对最老的未确认分组的定时器<ul>
<li>只需设置一个定时器</li>
<li>当定时器到时时，重传所有未确认分组</li>
</ul>
</li>
</ul>
</li>
<li>窗口滑动<ul>
<li>接收方正确收到数据包，向上递交和回复 ack ，接收窗口向后移动<ul>
<li>（ack 丢了也移动）<ul>
<li>这种情况，发送方会超时重发，遇到重复的包会认为是重发包，接收方依然会回复一个 ack</li>
</ul>
</li>
<li>（发送方正确收到 ack）<ul>
<li>只要收到窗口中的 ack，发送方窗口移动</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>SR：接收窗口尺寸&gt;1<ul>
<li>接收端<ul>
<li>可以乱序接收</li>
<li>对每个到来的分组发送单独确认 ACK——individual ack(非累计确认）</li>
</ul>
</li>
<li>发送端<ul>
<li>发送端最多在流水线中有 N 个未确认的分组</li>
<li>发送 0,1,2,3,4，一旦 1 未成功，2,3,4, 已发送，无需重发，<strong>选择性只发送 1</strong> </li>
<li>发送方为每个未确认的分组保持一个定时器<ul>
<li>当超时定时器到时，只是重发到时的未确认分组</li>
</ul>
</li>
</ul>
</li>
<li>窗口滑动<ul>
<li>发送方<ul>
<li>窗口最左边的包的 ack 到达了，窗口才会向后滑动</li>
</ul>
</li>
<li>接收方<ul>
<li>正确收到数据包，向上递交和回复 ack ，接收窗口向后移动<ul>
<li>（ack 丢了）</li>
<li>发送方超时重发，接收方知道是前面的重发包</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="GBN-过程"><a href="#GBN-过程" class="headerlink" title="GBN 过程"></a>GBN 过程</h4><ul>
<li>发送方扩展的FSM<ul>
<li><img src="image-20221116085704360.png" alt="image-20221116085704360"></li>
<li><code>next-base</code> 代表窗口大小，初始化 $1-1&#x3D;0$ </li>
<li>发送数据<ul>
<li><code>next-base</code> 再等于 0 时，SW 前沿向前滑动</li>
<li>如果分组序号在窗口范围之外，无法发送分组</li>
</ul>
</li>
<li>超时<ul>
<li>一定是最老的那个分组超时了，那么从 base 开始的 N 个分组，发送方都重新发送一遍（GoBackN）</li>
</ul>
</li>
<li>接收方收到分组并通过校验<ul>
<li>发送方收到 ACK 分组，具有 ACK 的序号 ACK_number，说明 number 及以前的分组都被正确的收到了，那么后沿向前滑动</li>
<li>如果 <code>base=next</code> ，即前后沿贴着，此时发送方没有已发送而未确认的分组，timer 关闭；否则重新启动 timer</li>
</ul>
</li>
</ul>
</li>
<li>接收方扩展的FSM<ul>
<li><img src="image-20221116085744772.png" alt="image-20221116085744772"></li>
<li><img src="image-20221116085808607.png" alt="image-20221116085808607"></li>
<li>初始化： <code>expected_seqnum=1</code> ，接收窗口从 1 号分组开始接收</li>
<li>接收方收到一个分组，通过校验没出错，序号和等待序号相等——接收<ul>
<li>解封装，上交</li>
<li>形成对该号分组的确认，发出 ACK</li>
<li>接收窗口前沿向前滑动</li>
</ul>
</li>
</ul>
</li>
<li><strong>运行中的 GBN</strong><ul>
<li><img src="image-20221116085823610.png" alt="image-20221116085823610"></li>
<li>接收方：总是 ACK 最后一个<strong>顺序到达</strong>的包，对于<strong>乱序到达</strong>的不回复对应序号的 ACK，而是回复重复的 ACK</li>
<li>发送方：超时后将所有没有 ACK 响应的包全部重传</li>
</ul>
</li>
</ul>
<h4 id="SR-过程"><a href="#SR-过程" class="headerlink" title="SR 过程"></a>SR 过程</h4><ul>
<li><p>接收方对每个正确接收的分组，分别发送 ACKn（非累积确认）</p>
<ul>
<li>接收窗口&gt;1<ul>
<li>可以缓存乱序的分组</li>
</ul>
</li>
<li>最终将分组按顺序交付给上层</li>
</ul>
</li>
<li><p>发送方只对那些没有收到 ACK 的分组进行重发-选择性重发</p>
<ul>
<li>发送方为每个未确认的分组设定一个定时器</li>
</ul>
</li>
<li><p>发送窗口的最大值（发送缓冲区）限制发送未确认分组的个数</p>
</li>
<li><p><img src="image-20221116085844952.png" alt="image-20221116085844952"></p>
</li>
<li><p><strong>运行过程</strong>：</p>
<p>  <img src="image-20221116085911716.png" alt="image-20221116085911716"></p>
</li>
<li><p><img src="image-20221116085927607.png" alt="image-20221116085927607"></p>
</li>
</ul>
<h4 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h4><p><img src="image-20221116085949768.png" alt="image-20221116085949768"></p>
<ul>
<li>出错率低：比较适合GBN，出错非常罕见，没有必要用复杂的SR，为罕见的事件做日常的准备和复杂处理</li>
<li>链路容量大（延迟大、带宽大）：比较适合SR而不是GBN，一点出错代价太大</li>
<li>GBN 也能较好的处理 ACK 中间包丢掉的情况，只要最后一个包的 ACK 就可以确认该编号之前的所有包都正确传送（累计响应）；SR 在该场景中，不能确认中间的正常，因此会重发中间的包</li>
</ul>
<h2 id="TCP：面向连接的传输"><a href="#TCP：面向连接的传输" class="headerlink" title="TCP：面向连接的传输"></a>TCP：面向连接的传输</h2><p>不同于RDT的停等，TCP为流水线协议</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li><p>点对点</p>
<ul>
<li>一个发送方，一个接收方</li>
<li>unicast 单播</li>
<li>如果希望一到多，只能一个个单独的建立连接</li>
</ul>
</li>
<li><p>可靠的、按顺序的字节流</p>
<ul>
<li>没有报文边界，将应用层交下来的数据仅视为一连串的无结构的字节流</li>
<li>可靠：无差错、不丢包、不重复、有序</li>
<li>发包的边界不由应用层决定，而由窗口决定</li>
</ul>
</li>
<li><p>管道化（流水线）</p>
<ul>
<li>TCP 拥塞控制和流量控制，共同决定当前窗口大小</li>
</ul>
</li>
<li><p>全双工数据</p>
<ul>
<li>在<strong>同一连接中，数据流双向移动（双向通信同时进行）</strong>，连接的两端都有发送缓存和接收缓存</li>
<li>MSS<ul>
<li><strong>maximum segment size</strong> 最大报文段大小（常考）</li>
<li>最大传送单元 MTU：当 IP 数据包封装成链路层的帧时，此数据包的总长度（即首部加上数据部分）一定不能超过下面的数据链路层所规定的 MTU 值。 </li>
<li>$MTU \stackrel{-head}{\rightarrow} max_datagram \stackrel{-head}{\rightarrow} max_segment$</li>
</ul>
</li>
</ul>
</li>
<li><p>面向连接</p>
<ul>
<li>在数据交换之前，通过<strong>握手（交换控制报文）初始化</strong>发送方、接收方的<strong>状态变量</strong></li>
</ul>
</li>
<li><p>流量控制</p>
<ul>
<li>发送方不会淹没接收方</li>
</ul>
</li>
</ul>
<h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><p><img src="image-20221117140402894.png" alt="image-20221117140402894"></p>
<h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h4><h5 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a><strong>端口号</strong></h5><ul>
<li>源端口号，占 16 位。</li>
<li>目标端口号，占 16 位。</li>
</ul>
<h5 id="序列号：占-32-位，确保了TCP传输的有序性"><a href="#序列号：占-32-位，确保了TCP传输的有序性" class="headerlink" title="序列号：占 32 位，确保了TCP传输的有序性"></a><strong>序列号</strong>：占 32 位，确保了TCP传输的<strong>有序性</strong></h5><ul>
<li>报文段的<strong>第一个字节</strong>在整个字节流里的编号</li>
<li><strong>并不是对包进行编号</strong></li>
<li>例子：每个报文的数据段4个字节，则第一个包填的序列号就是 0，下一个包的序列号就是 4<ul>
<li><img src="image-20221117140534672.png" alt="image-20221117140534672"></li>
</ul>
</li>
</ul>
<h5 id="ACK确认号"><a href="#ACK确认号" class="headerlink" title="ACK确认号"></a><strong>ACK确认号</strong></h5><ul>
<li><p>期望从另一方收到的下一个字节的序号</p>
</li>
<li><p><strong>累积确认</strong></p>
</li>
<li><p>例子 1</p>
<ul>
<li>正常情况<ul>
<li><img src="image-20221117140938499.png" alt="image-20221117140938499" style="zoom: 67%;"></li>
</ul>
</li>
<li>乱序到达&#x2F;丢包情况<ul>
<li>用<strong>编号重复的 ACK 来通知发送方</strong>，传输出现了问题</li>
<li><img src="image-20221117141032309.png" alt="image-20221117141032309" style="zoom:67%;"></li>
<li>在这个场景中，如果前两个 ack 包丢了，第三个回复了 ACK300，是可以累积确认的，接下来从 300 开始。</li>
</ul>
</li>
</ul>
</li>
<li><p>例子 2</p>
<ul>
<li><img src="image-20221117141219846.png" alt="image-20221117141219846" style="zoom: 50%;"></li>
<li>本例中包体部分只有 1 字节长</li>
<li>解释这个例子中包的形式<ul>
<li>每个包的 header 部分是定长字段，无论是 data 包还是 ack 包都会携带的（ack 包只有包头部分）</li>
<li>seq 记录自己向对方发了多少（outgoing），ack 记录对方向自己发了多少（incoming）</li>
<li><img src="image-20221117141357816.png" alt="image-20221117141357816"></li>
</ul>
</li>
<li>B 对 A 发送的包：B 收到了 42 号字节，期待的下一个（ACK）变为了 43</li>
<li>A 对 B 发送的第 2 个包：A 收到了 79 号，期待 80 号字节（ACK），但是这个包没有携带应用层的数据</li>
</ul>
</li>
</ul>
<h5 id="首部（包头）长度-head-length"><a href="#首部（包头）长度-head-length" class="headerlink" title="首部（包头）长度 head length"></a><strong>首部（包头）长度 head length</strong></h5><ul>
<li>标准的为 20 个字节长（默认）</li>
<li>有的携带了可选字段，那么就不止 20</li>
</ul>
<h5 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a><strong>标志位</strong></h5><ul>
<li>A：ACK<ul>
<li>置位为1，表示确认号 ACK 有效</li>
<li>除了 SYN 包，剩下所有的包中都含有 ACK，并且 ACKbit 都置位为 1</li>
</ul>
</li>
<li>S：SYN<ul>
<li>置位为 1 表示是 SYN 包，连接请求或连接接受</li>
</ul>
</li>
<li>R：RST<ul>
<li>置位为 1 表示是 RST 包，网络复位（出现严重差错）</li>
</ul>
</li>
<li>F：FIN<ul>
<li>置位为1 表示是 FIN 包，结束连接</li>
</ul>
</li>
<li>U：URG<ul>
<li>置位为 1，紧急数据，通常不使用</li>
</ul>
</li>
<li>P：PSH<ul>
<li>置位为 1，马上推出数据，而不必等到整个缓存都填满后再交付，通常不使用</li>
</ul>
</li>
</ul>
<h5 id="接收窗口：receive-window"><a href="#接收窗口：receive-window" class="headerlink" title="接收窗口：receive window"></a>接收窗口：receive window</h5><ul>
<li>每次 TCP 都会把自己的缓冲区剩余大小通知对方</li>
</ul>
<h4 id="TCP-往返延时（RTT）和超时"><a href="#TCP-往返延时（RTT）和超时" class="headerlink" title="TCP 往返延时（RTT）和超时"></a>TCP 往返延时（RTT）和超时</h4><p><strong>如何设置 timeout 超时时间</strong>：</p>
<ul>
<li>必须比 RTT 长，但是 RTT 会变化<ul>
<li>一般是比 RTT 稍微长一些，不能长太多</li>
</ul>
</li>
<li>太短：会出错，导致不必要的重传</li>
<li>太长：效率太差，对丢包的反应很慢</li>
<li>RTO：retransmission timeout，设置比正常的 RTT 稍微长一些</li>
</ul>
<p><strong>如何估算 RTT</strong>：</p>
<ul>
<li>对 RTT 的估算，每个操作系统有自己不一样的设计</li>
<li>采样 SampleRTT：发送方发一个数据包给对方，记录收到 ACK 的往返时间，就是一个采样值<ul>
<li>&#x3D;&#x3D;采样时忽略重传&#x3D;&#x3D;</li>
<li>不用重传包采样：重传会导致记录的往返时间出错，不是真实 RTT</li>
</ul>
</li>
<li>SampleRTT 采样值会动态变化，希望将 RTT 估计值更平滑<ul>
<li>&#x3D;&#x3D;平均&#x3D;&#x3D;几次采样结果，不是只用当前的 SampleRTT</li>
</ul>
</li>
<li>采样估计<ul>
<li>估算 RTT<ul>
<li><img src="image-20221117142154315.png" alt="image-20221117142154315" style="zoom: 67%;"></li>
<li>指数加权移动平均算法（ewma）：<ul>
<li>蓝色的是采样值，紫色基本能反映整个变化的趋势；</li>
<li>越久远的采样值的影响应该越低，越靠前的采样值的贡献应该越大</li>
<li>指数：每次整体带到公式去算，前面的都要乘一个比 1 小的 $(1-\alpha)$ ， $\alpha$ 是调节的重要参数</li>
</ul>
</li>
<li>会受到网络波动的影响</li>
<li>比较多的波动——说明网络拥塞了，RTT 才会慢慢增大</li>
</ul>
</li>
<li>估算 RTT 和 RTO 之间的相差的那一点偏移值（不细讲，明白意思）<ul>
<li><img src="image-20221117142422910.png" alt="image-20221117142422910"></li>
<li>如果采样时 RTT 比较稳定，偏移值就比较小，波动率较低，RTO 只需要比 RTT 稍多一点点即可</li>
<li>反之，RTO 要设的相对更大一点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="TCP的可靠数据传输"><a href="#TCP的可靠数据传输" class="headerlink" title="TCP的可靠数据传输"></a>TCP的可靠数据传输</h3><p>TCP 在 IP 的不可靠服务基础上，增加了可靠数据传输服务</p>
<ul>
<li><p>流水线传输</p>
</li>
<li><p><strong>累计响应（类似 GBN）</strong></p>
</li>
<li><p>只有单个重传计时器</p>
<ul>
<li>（和 SR 不一样，而和 GBN 一样）</li>
<li>ACK 回来之后，计时器重新开始计时，并绑定给刚刚 ACK 确认的下一个包</li>
<li>为什么：计时器需要消耗内核资源，多个计时器对资源的浪费太多</li>
</ul>
</li>
<li><p>重传触发</p>
<ul>
<li>RTO 超时重传<ul>
<li>比较慢</li>
</ul>
</li>
<li>快速重传<ul>
<li><img src="image-20221117142707143.png" alt="image-20221117142707143" style="zoom: 67%;"></li>
<li>对于乱序到达的包（第三个，seq&#x3D;120）不会丢，会缓存；接收方发现 seq 的 gap，回复 ACK100——重复编号的 ACK 意味着收到了乱序的包</li>
<li>如果在收到合法的 ACK 后，<strong>又连续收到 3 个重复 ACK</strong>，TCP 判定为丢包，触发快速重传</li>
<li>为什么要等 3 个，不在第 1 个就重传？可能第 2,3 个路由路径不一样而乱序到达，而不是丢包。（实际上也不会严格按照 3 个，如目前 Mac 是 12 个）</li>
</ul>
</li>
</ul>
</li>
<li><p>TCP ACK 的产生</p>
<p>  <img src="image-20221117143057361.png" alt="image-20221117143057361"></p>
</li>
</ul>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p><strong>流量控制：</strong>&#x3D;&#x3D;接收方控制发送方&#x3D;&#x3D;发包的速度，这样发送方不会因过快过多的数据传输，导致接收方缓冲区溢出</p>
<ul>
<li><p>&#x3D;&#x3D;<strong>sender window size &#x3D; min(rwnd, cwnd);</strong>&#x3D;&#x3D;(拥塞窗口和接受窗口的最小值)</p>
</li>
<li><p><strong>TCP 中接收方缓冲区不可能溢出！</strong> 最糟糕的情况也只是填满，通知发送方停止发送数据。</p>
</li>
<li><p>和互联网中间的<strong>路由器无关</strong>，是发送方、接收方两端的 TCP 模块做速度匹配</p>
</li>
<li><p>rwnd：receive window(由receiver TCP模块维护)</p>
<ul>
<li>每次 TCP 都会把自己的缓冲区<strong>剩余大小通知对方</strong></li>
<li><strong>三路握手</strong>时，SYN 包中会<strong>将自己的初始缓冲区大小告诉对方。</strong></li>
<li>sender 发送方每次发送的包的大小，取决于接收方 ACK 中携带的 rwnd 信息，即缓冲区剩余空间<ul>
<li>若剩余空间为 0，发送方无法继续发送数据；（发送方会启动一个探测超时器，超时后发送方的 TCP 会发送一个探测包，接收方回复的 ACK 就会携带最新的 rwnd 值，直到接收方缓冲区有空间。{这部分不要求}）</li>
</ul>
</li>
<li>发送窗口在滑动的同时，窗口大小根据对方的 ACK 中的 rwnd 值动态调整！</li>
<li>收到 Data 和发送 ACK 之间有个延迟（便于另一端 ACK+Data 在同一个包中传），在这个延迟中，如果接收方向上层交付了数据（数量不定），那么接收方的 rwnd 就会调整到某个值，最终返回给接收方；如果没有交付，那么就是缓冲区大小减去这次收到的数据大小。</li>
</ul>
</li>
</ul>
<p><img src="image-20221117143356240.png" alt="image-20221117143356240"></p>
<h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p>在正式交换数据之前，发送方和接收方握手建立通信关系:  </p>
<ul>
<li><strong>同意建立连接（每一方都知道对方愿意建立连接）</strong>  </li>
<li><strong>同意连接参数</strong></li>
</ul>
<h4 id="建立连接——三路握手"><a href="#建立连接——三路握手" class="headerlink" title="建立连接——三路握手"></a>建立连接——三路握手</h4><p><img src="image-20221117143846299.png" alt="image-20221117143846299"></p>
<ol>
<li><strong>SYN 包（synchronize 同步）</strong><ul>
<li>由客户端进程发给服务器进程</li>
<li>只有包头而不携带数据，各个字段：<ul>
<li>SYNbit&#x3D;1</li>
<li>序列号 ：由 TCP“随机”选择一个 x 作为初始序列号—— $ISN_c$ (Initial Sequence Number)；<ul>
<li>“随机”选择初始序列号：防止被猜到而被攻击</li>
</ul>
</li>
<li>ACK 确认号：无意义，可以认为是随机值</li>
<li>rwnd</li>
<li>MSS 最大报文段大小，告诉对方不要发大于这个大小的</li>
</ul>
</li>
<li>同步各个网络参数</li>
</ul>
</li>
<li><strong>SYN，ACK 包</strong><ul>
<li>服务器进程回复给客户端进程，同样需要携带各个网络参数</li>
<li>只有包头而不携带数据：<ul>
<li>新选择一个 y，作为初始序列号 $ISN_s$</li>
</ul>
</li>
<li>此外，这个包还是一个 ACK 包<ul>
<li>ACKbit&#x3D;1，ACK 确认号 $&#x3D;ISN_c+1&#x3D;x+1$</li>
</ul>
</li>
</ul>
</li>
<li><strong>ACK 包</strong><ul>
<li>客户端发给服务器</li>
<li>seq 序列号 $&#x3D;ISN_c+1$ ，ACK 确认号 $&#x3D;ISN_s+1$</li>
<li>这个包可以携带数据，<strong>携带数据时消耗编号</strong>，若<strong>不携带数据则不消耗序号</strong>（下一个携带应用层的数据包seq  $&#x3D;ISN_c+1$）</li>
</ul>
</li>
</ol>
<p><strong>成功进行以上三步（三次握手）后，就建立了 TCP 连接。</strong></p>
<p>接下来客户端发给服务器的编号，第一个数据包的 seq 序列号是 $ISN_c+1$ </p>
<ol>
<li>RST 包<ul>
<li>在一些场景中，服务器回复的不是 SYNACK，而是 RST</li>
<li>RST——reset，网络复位，R 字段为 1</li>
<li>连接立刻断开，遇到了不可恢复的错误，需要复位。（如服务器可能被 DDos 攻击）</li>
</ul>
</li>
</ol>
<h4 id="为什么不能两路握手？"><a href="#为什么不能两路握手？" class="headerlink" title="为什么不能两路握手？"></a>为什么不能两路握手？</h4><p>两路握手的失败场景：</p>
<p><img src="image-20221117145409164.png" alt="image-20221117145409164"></p>
<ul>
<li><p>可能发送半连接（只在服务器维护了连接）  </p>
</li>
<li><p>老的数据被当成新的数据接收了 <strong>seq x 和 x + 1</strong></p>
</li>
<li><p>变化的延迟（没丢包，但是可能超时）</p>
</li>
<li><p>丢包重传</p>
</li>
<li><p>报文乱序</p>
</li>
</ul>
<h4 id="关闭连接——四路挥手"><a href="#关闭连接——四路挥手" class="headerlink" title="关闭连接——四路挥手"></a>关闭连接——四路挥手</h4><p><img src="image-20221117145444274.png" alt="image-20221117145444274"></p>
<ol>
<li><p>FIN 包</p>
<ul>
<li>FIN(final)，FINbit&#x3D;1</li>
<li>通知对方，自己这边应用层的数据已经发送结束，之后不会再发送数据。不代表立刻断开连接，远端仍然能够发送数据</li>
</ul>
</li>
<li><p>ACK 包</p>
<ul>
<li>ACK 包发完之后，客户端不会再发送数据了，服务器还能够发送数据</li>
</ul>
</li>
<li><p>FIN 包 2</p>
<p> 另一边的数据也发送结束，过程同上</p>
</li>
<li><p>ACK 包 2</p>
</li>
</ol>
<ul>
<li>服务器收到客户端的 ACK 就可以断开连接了</li>
<li>客户端送出 ACK 后，会等待一段足够长的时间（看服务器是否重发 FIN 包，了解到 ACK 包是否发送成功），才会断开连接</li>
</ul>
<img src="image-20221117145928007.png" alt="image-20221117145928007" style="zoom: 67%;">

<ul>
<li><p>与 SYN 包消耗一个序列号类似，FIN 包也会消耗掉一个序列号</p>
</li>
<li><p>本例中，FIN 由客户端先发起，实际上两边都可能先发起（与 SYN 一直是客户端先发起有区别）</p>
</li>
</ul>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>不同于流量控制（sender和receiver之间），<strong>是sender和路由器之间的流量控制。</strong></p>
<p>过载（<strong>拥塞</strong>）：路由的<strong>转化速率（信号转化到链路上）</strong>比较慢，当buffer满了后，路由器会将收到的数据包直接丢掉。原因为较短时间内收到的数据包过多。</p>
<p>解决拥塞：<strong>sender降速</strong>（减小滑动窗口的大小）</p>
<h3 id="拥塞控制图例"><a href="#拥塞控制图例" class="headerlink" title="拥塞控制图例"></a>拥塞控制图例</h3><p><img src="image-20221121094256151.png" alt="shadow-image-20221121094256151"></p>
<p><strong>解释：</strong></p>
<ul>
<li>拥塞窗口（纵坐标）：等于接受（发送）窗口大小，由<strong>sender TCP模块自行维护的值</strong>，即cwnd,<strong>单位 byte（图中单位为segments,即MSS）</strong></li>
<li>横坐标：传输轮次</li>
</ul>
<p><strong>阶段说明：</strong></p>
<ul>
<li><strong>慢启动（slow start,SS）阶段：</strong><ul>
<li>round1:&#x3D;&#x3D;cwnd&#x3D;1（初始值为1）&#x3D;&#x3D; swnd&#x3D; 1（启动时速率很保守）（数据包seq &#x3D; ISN+1）</li>
<li><strong>round2-3:</strong> &#x3D;&#x3D;<strong>1个ACK正常返回，cwnd+1（多个包返回相当于指数增长）</strong>&#x3D;&#x3D;，swnd &#x3D; cwnd，翻倍</li>
</ul>
</li>
<li><strong>拥塞避免（congestion avoiding）阶段：</strong><ul>
<li>**round4-8:**到SS阈值，主动降速，&#x3D;&#x3D;<strong>每返回一个ACK，cwnd +&#x3D; 1&#x2F;cwnd</strong>&#x3D;&#x3D;（相当于每轮只增加1），若无丢包，会持续增长直到用完带宽</li>
</ul>
</li>
<li><strong>发生丢包(预设发生拥塞)：</strong>两种情况<ul>
<li>round9: <strong>RTO超时丢包（1个包都没回来）</strong>&#x3D;&#x3D;<strong>丢包后降速至初始值1,同步降低SS阈值（cwnd &#x3D; 丢包时cwnd&#x2F;2）</strong>&#x3D;&#x3D;，继续慢启动</li>
<li>round9:<strong>部分丢包（收到3个重复的ACK）</strong>&#x3D;&#x3D;<strong>丢包后降速至SS阈值（cwnd &#x3D; 丢包时cwnd&#x2F;2）</strong>&#x3D;&#x3D;，继续线性增加</li>
</ul>
</li>
</ul>
<h3 id="TCP阻塞控制特点"><a href="#TCP阻塞控制特点" class="headerlink" title="TCP阻塞控制特点"></a>TCP阻塞控制特点</h3><p><strong>特点：</strong></p>
<ul>
<li>加法增长：线性增加</li>
<li>乘法下降：腰斩下降</li>
<li>RTO超时重新初始化基本不会发生</li>
<li>已经丢包才降速，效率很差</li>
</ul>
<p><img src="image-20221121094620832.png" alt="image-20221121094620832"></p>
<p><strong>阻塞控制内核的升级：</strong></p>
<ul>
<li>1.0 tahoe:丢包只初始化到1</li>
<li>2.0 reno:考虑部分丢包</li>
<li>3.0 cubic:即将丢包时就小部分降速，只有发生丢包才降到一半cwnd</li>
</ul>
<h3 id="FSM-了解"><a href="#FSM-了解" class="headerlink" title="FSM(了解)"></a>FSM(了解)</h3><p><img src="image-20221121095442291.png" alt="image-20221121095442291"></p>
<h3 id="TCP公平性"><a href="#TCP公平性" class="headerlink" title="TCP公平性"></a>TCP公平性</h3><p><img src="image-20221121101035922.png" alt="image-20221121101035922"></p>
<p>如果K个TCP sessions 共享同一条带宽为R的瓶颈链路，则每个TCP会话的<strong>平均速率应为R&#x2F;K</strong>，即max-min fainness原则（不能劫贫济富）</p>
<p>假设瓶颈链路带宽为10，有以下几种情况：</p>
<table>
<thead>
<tr>
<th align="center">要求带宽</th>
<th align="center">实际分配带宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">5， 5</td>
<td align="center">5， 5</td>
</tr>
<tr>
<td align="center">3， 3</td>
<td align="center">3， 3</td>
</tr>
<tr>
<td align="center">6， 6</td>
<td align="center">6， 6</td>
</tr>
<tr>
<td align="center">4， 6</td>
<td align="center">4， 6</td>
</tr>
<tr>
<td align="center">4， 7</td>
<td align="center">4， 6</td>
</tr>
<tr>
<td align="center">5， 10</td>
<td align="center">5， 10</td>
</tr>
</tbody></table>
<p><strong>带宽动态分配：</strong></p>
<p><img src="image-20221121103306002.png" alt="image-20221121103306002"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://guoxi-zhang.github.io">Guoxi Zhang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://guoxi-zhang.github.io/2023/01/16/3%E4%BC%A0%E8%BE%93%E5%B1%82/">https://guoxi-zhang.github.io/2023/01/16/3%E4%BC%A0%E8%BE%93%E5%B1%82/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://guoxi-zhang.github.io" target="_blank">Guoxi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%A7%E4%B8%89%E7%AC%AC%E4%B8%80%E5%AD%A6%E6%9C%9F/">大三第一学期</a><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%BD%91/">计网</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/Guoxi-Zhang/myBlog/main/public/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/16/4%E7%BD%91%E7%BB%9C%E5%B1%82/" title="计算机网络——第四章：网络层"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机网络——第四章：网络层</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/16/2%E5%BA%94%E7%94%A8%E5%B1%82/" title="计算机网络——第二章：应用层"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络——第二章：应用层</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/16/2%E5%BA%94%E7%94%A8%E5%B1%82/" title="计算机网络——第二章：应用层"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-16</div><div class="title">计算机网络——第二章：应用层</div></div></a></div><div><a href="/2023/01/16/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络——第一章：计网简介"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-16</div><div class="title">计算机网络——第一章：计网简介</div></div></a></div><div><a href="/2023/01/16/5%E9%93%BE%E8%B7%AF%E5%B1%82/" title="计算机网络——第五章：链路层"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-16</div><div class="title">计算机网络——第五章：链路层</div></div></a></div><div><a href="/2023/01/16/4%E7%BD%91%E7%BB%9C%E5%B1%82/" title="计算机网络——第四章：网络层"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-16</div><div class="title">计算机网络——第四章：网络层</div></div></a></div><div><a href="/2023/01/15/SEReview/" title="软件工程知识点复习总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">软件工程知识点复习总结</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/Guoxi-Zhang/myBlog/main/public/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Guoxi Zhang</div><div class="author-info__description">Present is a present.</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Guoxi-Zhang"><i class="fab fa-github"></i><span>view my github</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">1.</span> <span class="toc-text">传输层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">传输层概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.1.</span> <span class="toc-text">和网络层对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.1.2.</span> <span class="toc-text">传输协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-multiplexing-%E4%B8%8E%E5%88%86%E8%A7%A3-demultiplexing"><span class="toc-number">1.2.</span> <span class="toc-text">多路复用(multiplexing)与分解(demultiplexing)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E8%A7%A3%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.1.</span> <span class="toc-text">分解原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP-%E6%97%A0%E8%BF%9E%E6%8E%A5%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.3.</span> <span class="toc-text">UDP:无连接传输层协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.</span> <span class="toc-text">报文结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E5%92%8C"><span class="toc-number">1.3.2.</span> <span class="toc-text">校验和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">可靠数据传输原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0RDT"><span class="toc-number">1.4.1.</span> <span class="toc-text">构造RDT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt-1-0-%E7%BB%8F%E5%AE%8C%E5%85%A8%E5%8F%AF%E9%9D%A0%E4%BF%A1%E9%81%93"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">rdt 1.0 经完全可靠信道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt-2-0-%E7%BB%8F%E5%85%B7%E6%9C%89%E6%AF%94%E7%89%B9%E5%B7%AE%E9%94%99%E4%BF%A1%E9%81%93"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">rdt 2.0 经具有比特差错信道</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#rdt-2-1"><span class="toc-number">1.4.1.2.1.</span> <span class="toc-text">rdt 2.1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rdt2-2%EF%BC%9A%E6%97%A0-NAK-%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.4.1.2.2.</span> <span class="toc-text">rdt2.2：无 NAK 的协议</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt-3-0%E7%BB%8F%E5%85%B7%E6%9C%89%E6%AF%94%E7%89%B9%E5%B7%AE%E9%94%99%E7%9A%84%E4%B8%A2%E5%8C%85%E4%BF%A1%E9%81%93"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">rdt 3.0经具有比特差错的丢包信道</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.4.2.</span> <span class="toc-text">流水线可靠数据传输协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GBN-go-Back-N"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">GBN (go-Back-N)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SR-selective-repeat"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">SR (selective repeat)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%A6%82%E8%BF%B0"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">滑动窗口概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.2.3.1.</span> <span class="toc-text">滑动窗口实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8D%8F%E8%AE%AE%E8%AE%A8%E8%AE%BA"><span class="toc-number">1.4.3.</span> <span class="toc-text">流水线协议讨论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8D%8F%E8%AE%AE%E4%B8%8B%E7%9A%84%E7%AA%97%E5%8F%A3%E4%BA%92%E5%8A%A8"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">流水线协议下的窗口互动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GBN-%E5%8D%8F%E8%AE%AE%E5%92%8C-SR-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">1.4.4.</span> <span class="toc-text">GBN 协议和 SR 协议的异同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GBN-%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">GBN 过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SR-%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">SR 过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">优缺点对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%EF%BC%9A%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93"><span class="toc-number">1.5.</span> <span class="toc-text">TCP：面向连接的传输</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A5%E6%96%87"><span class="toc-number">1.5.2.</span> <span class="toc-text">报文</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E8%A7%A3%E6%9E%90"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">字段解析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">1.5.2.1.1.</span> <span class="toc-text">端口号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8F%B7%EF%BC%9A%E5%8D%A0-32-%E4%BD%8D%EF%BC%8C%E7%A1%AE%E4%BF%9D%E4%BA%86TCP%E4%BC%A0%E8%BE%93%E7%9A%84%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">1.5.2.1.2.</span> <span class="toc-text">序列号：占 32 位，确保了TCP传输的有序性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ACK%E7%A1%AE%E8%AE%A4%E5%8F%B7"><span class="toc-number">1.5.2.1.3.</span> <span class="toc-text">ACK确认号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A6%96%E9%83%A8%EF%BC%88%E5%8C%85%E5%A4%B4%EF%BC%89%E9%95%BF%E5%BA%A6-head-length"><span class="toc-number">1.5.2.1.4.</span> <span class="toc-text">首部（包头）长度 head length</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="toc-number">1.5.2.1.5.</span> <span class="toc-text">标志位</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3%EF%BC%9Areceive-window"><span class="toc-number">1.5.2.1.6.</span> <span class="toc-text">接收窗口：receive window</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E5%BE%80%E8%BF%94%E5%BB%B6%E6%97%B6%EF%BC%88RTT%EF%BC%89%E5%92%8C%E8%B6%85%E6%97%B6"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">TCP 往返延时（RTT）和超时</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-number">1.5.3.</span> <span class="toc-text">TCP的可靠数据传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">1.5.4.</span> <span class="toc-text">流量控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.5.</span> <span class="toc-text">连接管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E2%80%94%E2%80%94%E4%B8%89%E8%B7%AF%E6%8F%A1%E6%89%8B"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">建立连接——三路握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%B8%A4%E8%B7%AF%E6%8F%A1%E6%89%8B%EF%BC%9F"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">为什么不能两路握手？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%E2%80%94%E2%80%94%E5%9B%9B%E8%B7%AF%E6%8C%A5%E6%89%8B"><span class="toc-number">1.5.5.3.</span> <span class="toc-text">关闭连接——四路挥手</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">1.6.</span> <span class="toc-text">TCP拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%9B%BE%E4%BE%8B"><span class="toc-number">1.6.1.</span> <span class="toc-text">拥塞控制图例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E9%98%BB%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%89%B9%E7%82%B9"><span class="toc-number">1.6.2.</span> <span class="toc-text">TCP阻塞控制特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FSM-%E4%BA%86%E8%A7%A3"><span class="toc-number">1.6.3.</span> <span class="toc-text">FSM(了解)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%85%AC%E5%B9%B3%E6%80%A7"><span class="toc-number">1.6.4.</span> <span class="toc-text">TCP公平性</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/16/5%E9%93%BE%E8%B7%AF%E5%B1%82/" title="计算机网络——第五章：链路层">计算机网络——第五章：链路层</a><time datetime="2023-01-15T16:09:53.627Z" title="发表于 2023-01-16 00:09:53">2023-01-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/16/4%E7%BD%91%E7%BB%9C%E5%B1%82/" title="计算机网络——第四章：网络层">计算机网络——第四章：网络层</a><time datetime="2023-01-15T16:09:53.619Z" title="发表于 2023-01-16 00:09:53">2023-01-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/16/3%E4%BC%A0%E8%BE%93%E5%B1%82/" title="计算机网络——第三章：传输层">计算机网络——第三章：传输层</a><time datetime="2023-01-15T16:09:53.610Z" title="发表于 2023-01-16 00:09:53">2023-01-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/16/2%E5%BA%94%E7%94%A8%E5%B1%82/" title="计算机网络——第二章：应用层">计算机网络——第二章：应用层</a><time datetime="2023-01-15T16:09:53.602Z" title="发表于 2023-01-16 00:09:53">2023-01-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/16/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络——第一章：计网简介">计算机网络——第一章：计网简介</a><time datetime="2023-01-15T16:09:53.594Z" title="发表于 2023-01-16 00:09:53">2023-01-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://raw.githubusercontent.com/Guoxi-Zhang/myBlog/main/public/img/top_img1.jpeg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Guoxi Zhang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>